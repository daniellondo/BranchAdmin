{"ast":null,"code":"import { __decorate, __metadata } from \"tslib\";\nimport { Component, ElementRef, ViewChild } from \"@angular/core\";\nimport { DataService } from \"./services/data.service\";\nimport { HttpClient } from \"@angular/common/http\";\nimport { MatDialog } from \"@angular/material/dialog\";\nimport { MatPaginator } from \"@angular/material/paginator\";\nimport { MatSort } from \"@angular/material/sort\";\nimport { DataSource } from \"@angular/cdk/collections\";\nimport { AddDialogComponent } from \"./dialogs/add/add.dialog.component\";\nimport { EditDialogComponent } from \"./dialogs/edit/edit.dialog.component\";\nimport { DeleteDialogComponent } from \"./dialogs/delete/delete.dialog.component\";\nimport { BehaviorSubject, fromEvent, merge } from \"rxjs\";\nimport { Branch } from \"./models/branch\";\nlet AppComponent = class AppComponent {\n  constructor(httpClient, dialog, dataService) {\n    this.httpClient = httpClient;\n    this.dialog = dialog;\n    this.dataService = dataService;\n    this.displayedColumns = [\"Code\", \"Address\", \"Identification\", \"CreationDate\", \"Currency\", \"Actions\"];\n  }\n\n  ngOnInit() {\n    this.loadData();\n  }\n\n  refresh() {\n    this.loadData();\n  }\n\n  addNew() {\n    const dialogRef = this.dialog.open(AddDialogComponent, {\n      data: {\n        branch: Branch\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result === 1) {\n        // After dialog is closed we're doing frontend updates\n        // For add we're just pushing a new row inside DataService\n        this.exampleDatabase.dataChange.value.push(this.dataService.getDialogData());\n        this.refreshTable();\n      }\n    });\n  }\n\n  startEdit(branchId, code, description, address, identification, createDate, currency) {\n    this.branchId = branchId;\n    const dialogRef = this.dialog.open(EditDialogComponent, {\n      data: {\n        branchId: branchId,\n        code: code,\n        description: description,\n        address: address,\n        identification: identification,\n        createDate: createDate,\n        currency: currency\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result === 1 && this.exampleDatabase) {\n        const foundIndex = this.exampleDatabase.dataChange.value.findIndex(x => x.branchId === this.branchId);\n        this.exampleDatabase.dataChange.value[foundIndex] = this.dataService.getDialogData();\n        this.refreshTable();\n      }\n    });\n  }\n\n  deleteItem(branchId, code, description, address, identification, createDate, currency) {\n    this.branchId = branchId;\n    const dialogRef = this.dialog.open(DeleteDialogComponent, {\n      data: {\n        branchId: branchId,\n        code: code,\n        description: description,\n        address: address,\n        identification: identification,\n        createDate: createDate,\n        currency: currency\n      }\n    });\n    dialogRef.afterClosed().subscribe(result => {\n      if (result === 1 && this.exampleDatabase) {\n        const foundIndex = this.exampleDatabase.dataChange.value.findIndex(x => x.branchId === this.branchId);\n        this.exampleDatabase.dataChange.value.splice(foundIndex, 1);\n        this.refreshTable();\n      }\n    });\n  }\n\n  refreshTable() {\n    this.paginator._changePageSize(this.paginator.pageSize);\n  }\n\n  loadData() {\n    this.exampleDatabase = new DataService(this.httpClient);\n    this.dataSource = new ExampleDataSource(this.exampleDatabase, this.paginator, this.sort);\n    fromEvent(this.filter.nativeElement, \"keyup\") // .debounceTime(150)\n    // .distinctUntilChanged()\n    .subscribe(() => {\n      if (!this.dataSource) {\n        return;\n      }\n\n      this.dataSource.filter = this.filter.nativeElement.value;\n    });\n  }\n\n};\n\n__decorate([ViewChild(MatPaginator, {\n  static: true\n}), __metadata(\"design:type\", MatPaginator)], AppComponent.prototype, \"paginator\", void 0);\n\n__decorate([ViewChild(MatSort, {\n  static: true\n}), __metadata(\"design:type\", MatSort)], AppComponent.prototype, \"sort\", void 0);\n\n__decorate([ViewChild(\"filter\", {\n  static: true\n}), __metadata(\"design:type\", ElementRef)], AppComponent.prototype, \"filter\", void 0);\n\nAppComponent = __decorate([Component({\n  selector: \"app-root\",\n  templateUrl: \"./app.component.html\",\n  styleUrls: [\"./app.component.css\"]\n}), __metadata(\"design:paramtypes\", [HttpClient, MatDialog, DataService])], AppComponent);\nexport { AppComponent };\nexport class ExampleDataSource extends DataSource {\n  constructor(_exampleDatabase, _paginator, _sort) {\n    super();\n    this._exampleDatabase = _exampleDatabase;\n    this._paginator = _paginator;\n    this._sort = _sort;\n    this._filterChange = new BehaviorSubject(\"\");\n    this.filteredData = [];\n    this.renderedData = []; // Reset to the first page when the user changes the filter.\n\n    this._filterChange.subscribe(() => this._paginator.pageIndex = 0);\n  }\n\n  get filter() {\n    return this._filterChange.value;\n  }\n\n  set filter(filter) {\n    this._filterChange.next(filter);\n  }\n  /** Connect function called by the table to retrieve one stream containing the data to render. */\n\n\n  connect() {\n    // Listen for any changes in the base data, sorting, filtering, or pagination\n    const displayDataChanges = [this._exampleDatabase.dataChange, this._sort.sortChange, this._filterChange, this._paginator.page];\n\n    this._exampleDatabase.getAllBranchs();\n\n    return merge(...displayDataChanges, this._exampleDatabase.data);\n  }\n\n  disconnect() {}\n  /** Returns a sorted copy of the database data. */\n\n\n  sortData(data) {\n    if (!this._sort.active || this._sort.direction === \"\") {\n      return data;\n    }\n\n    return data.sort((a, b) => {\n      let propertyA = \"\";\n      let propertyB = \"\";\n\n      switch (this._sort.active) {\n        case 'branchId':\n          [propertyA, propertyB] = [a.branchId, b.branchId];\n          break;\n\n        case 'code':\n          [propertyA, propertyB] = [a.code, b.code];\n          break;\n\n        case 'description':\n          [propertyA, propertyB] = [a.description, b.description];\n          break;\n\n        case 'identification':\n          [propertyA, propertyB] = [a.identification, b.identification];\n          break;\n\n        case 'currency':\n          [propertyA, propertyB] = [a.currency, b.currency];\n          break;\n\n        case 'createDate':\n          [propertyA, propertyB] = [a.createDate, b.createDate];\n          break;\n\n        case 'address':\n          [propertyA, propertyB] = [a.address, b.address];\n          break;\n      }\n\n      const valueA = isNaN(+propertyA) ? propertyA : +propertyA;\n      const valueB = isNaN(+propertyB) ? propertyB : +propertyB;\n      return (valueA < valueB ? -1 : 1) * (this._sort.direction === \"asc\" ? 1 : -1);\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}